package kimsufi

import (
	"encoding/json"
	"fmt"
	"io/ioutil"
	"net/http"
	"sort"
	"strconv"
	"strings"
	"sync"
	"time"

	"gopkg.in/fatih/set.v0"

	"github.com/rockneurotiko/go-tgbot"
	"github.com/syndtr/goleveldb/leveldb"
)

const (
	VERSION = "1.0"

	API_URL = "https://ws.ovh.com/dedicated/r2/ws.dispatcher/getAvailability2"
)

var (
	ZONES = map[string]string{
		"gra": "Gravelines",
		"sbg": "Strasbourg",
		"rbx": "Roubaix",
		"bhs": "Beauharnois",
	}

	REFERENCES = map[string]string{
		"150sk10": "KS-1",
		"150sk20": "KS-2",
		"150sk21": "KS-2",
		"150sk22": "KS-2-SSD",
		"150sk30": "KS-3",
		"150sk31": "KS-3",
		"150sk40": "KS-4",
		"150sk41": "KS-4",
		"150sk42": "KS-4",
		"150sk50": "KS-5",
		"150sk60": "KS-6",

		"141game1": "GAME-1",
		"141game2": "GAME-2",
		"141game3": "GAME-3",

		"142sys4":  "SYS-IP-1",
		"142sys5":  "SYS-IP-2",
		"142sys8":  "SYS-IP-4",
		"142sys6":  "SYS-IP-5",
		"142sys10": "SYS-IP-5S",
		"142sys7":  "SYS-IP-6",
		"142sys9":  "SYS-IP-6S",

		"143sys13": "E3-SSD-1",
		"143sys10": "E3-SSD-2",
		"143sys11": "E3-SSD-3",
		"143sys12": "E3-SSD-4",

		"143sys4": "E3-SAT-1",
		"143sys1": "E3-SAT-2",
		"143sys2": "E3-SAT-3",
		"143sys3": "E3-SAT-4",

		"141bk1": "BK-8T",
		"141bk2": "BK-24T",
	}
)

type Availability struct {
	Class            string `json:"__class"`
	Displaymetazones int    `json:"displayMetazones"`
	Reference        string `json:"reference"`
	Metazones        []struct {
		Class        string `json:"__class"`
		Availability string `json:"availability"`
		Zone         string `json:"zone"`
	} `json:"metaZones"`
	Zones []struct {
		Class        string `json:"__class"`
		Availability string `json:"availability"`
		Zone         string `json:"zone"`
	} `json:"zones"`
}

type Autogenerated struct {
	Answer struct {
		Class        string         `json:"__class"`
		Availability []Availability `json:"availability"`
	} `json:"answer"`
	Version string `json:"version"`
	Error   string `json:"error,omitempty"`
	ID      int    `json:"id"`
}

func get_servers() []Availability {
	result := make([]Availability, 0)
	res, err := http.Get(API_URL)
	if err != nil {
		return result
	}
	bytes, err := ioutil.ReadAll(res.Body)
	res.Body.Close()
	if err != nil {
		return result
	}

	var m Autogenerated
	json.Unmarshal(bytes, &m)

	answer := m.Answer.Availability
	search := REFERENCES

	for _, server := range answer {
		for s, _ := range search {
			if server.Reference == s {
				result = append(result, server)
			}
		}
	}
	return result
}

func get_zone_name(z string) string {
	zone := strings.Split(z, "-")[0]
	if val, ok := ZONES[zone]; ok {
		return val
	}
	return zone
}

func stringInSlice(a string, list []string) bool {
	for _, b := range list {
		if b == a {
			return true
		}
	}
	return false
}

func filter_servers(s []Availability, filter []string) []Availability {
	newa := make([]Availability, 0)
	newf := make(map[string]bool)

	// if len(filter) == 0 {
	// 	return s
	// }

	for k, f := range REFERENCES {
		if stringInSlice(f, filter) {
			newf[k] = true
		}
	}

	for _, a := range s {
		if newf[a.Reference] {
			newa = append(newa, a)
		}
	}

	return newa
}

func servers_to_string(s []Availability, filter []string) (string, bool) {
	total := 0
	output := ""

	invalids := map[string]bool{"unavailable": true, "unknown": true}

	s = filter_servers(s, filter)

	outputtoadd := ""
	for _, a := range s {
		outputtoadd += fmt.Sprintf("\n%s\n", REFERENCES[a.Reference])
		outputtoadd += fmt.Sprintf("%s\n", strings.Repeat("=", len(REFERENCES[a.Reference])))
		some := false
		for _, z := range a.Zones {
			availability := z.Availability
			if !invalids[availability] {
				some = true
				total += 1
				outputtoadd += fmt.Sprintf("%s : %s\n", get_zone_name(z.Zone), availability)
			}
		}
		if some {
			output += outputtoadd
		}
		outputtoadd = ""
	}

	ss := ""
	if total >= 1 {
		ss = "s"
	}

	conj := "is"
	if total > 1 {
		conj = "are"
	}

	output += fmt.Sprintf("\n=======\nRESULT : %d server%s %s available on Kimsufi\n=======\n", total, ss, conj)

	return output, total > 1
}

func subscribe(bot tgbot.TgBot, msg tgbot.Message, text string) *string {
	id := msg.From.ID
	subscribers.setUserSub(id, true)

	autodb.saveInDb(map[string]string{
		fmt.Sprintf("kimsufi:%d:active", msg.From.ID): "true",
	})

	bot.Answer(msg).Text(`Subscribed!
Now you need to add some filters to your subscription, send me the command /filters to know the available filters, and /myfilters to know your subscribed filters.`).End()
	return nil
}

func unsubscribe(bot tgbot.TgBot, msg tgbot.Message, text string) *string {
	id := msg.From.ID
	subscribers.setUserSub(id, false)

	autodb.saveInDb(map[string]string{
		fmt.Sprintf("kimsufi:%d:active", msg.From.ID): "false",
	})

	bot.Answer(msg).Text(`Unsubscribed!
Your filters are still saved, if you want to remove them send me the command /cleanfilters`).End()
	return nil
}

type User struct {
	Active bool
	Zones  []string
}

type Subs struct {
	*sync.RWMutex
	Subscribers map[int]User
}

func (self *Subs) setAll(us map[int]User) {
	self.Lock()
	self.Subscribers = us
	self.Unlock()
}

func (self Subs) getAll() map[int]User {
	self.RLock()
	defer self.RUnlock()
	return self.Subscribers
}

func (self *Subs) setUserSub(id int, b bool) {
	self.Lock()
	v, ok := self.Subscribers[id]
	if !ok {
		self.Subscribers[id] = User{b, make([]string, 0)}
	} else {
		self.Subscribers[id] = User{b, v.Zones}
	}
	self.Unlock()
}

func (self *Subs) getUser(id int) (User, bool) {
	self.RLock()
	v, ok := self.Subscribers[id]
	self.RUnlock()
	return v, ok
}

func (self *Subs) cleanFilters(id int) {
	self.Lock()
	v, _ := self.Subscribers[id]
	self.Subscribers[id] = User{v.Active, make([]string, 0)}

	self.Unlock()
}

func (self *Subs) addFilter(id int, f string) []string {
	self.Lock()
	v, ok := self.Subscribers[id]
	newone := append(v.Zones, f)
	if !ok {
		self.Subscribers[id] = User{v.Active, newone}
	} else {
		self.Subscribers[id] = User{v.Active, newone}
	}
	self.Unlock()
	return newone
}

func (self *Subs) rmFilter(id int, f string) []string {
	newf := make([]string, 0)
	self.Lock()
	v, ok := self.Subscribers[id]
	if !ok {
		self.Subscribers[id] = User{false, newf}
	} else {
		for _, v := range v.Zones {
			if v != f {
				newf = append(newf, v)
			}
		}
		if len(newf) < len(v.Zones) {
			self.Subscribers[id] = User{v.Active, newf}
		}
	}
	self.Unlock()
	return newf
}

var subscribers = Subs{
	&sync.RWMutex{},
	make(map[int]User),
}

func analyzer(bot tgbot.TgBot) {
	for {
		servers := get_servers()

		users := subscribers.getAll()
		for id, v := range users {
			serverss, ok := servers_to_string(servers, v.Zones)
			if ok && v.Active {
				bot.Send(id).Text(serverss).End()
			}
		}

		// <-time.After(1 * time.Minute)
		<-time.After(15 * time.Second)
	}
}

func saveFilters(id int, fils []string) {
	autodb.saveInDb(map[string]string{
		fmt.Sprintf("kimsufi:%d:filters", id): strings.Join(fils, ":"),
	})
}

func addfilter(bot tgbot.TgBot, msg tgbot.Message, args []string, kargs map[string]string) *string {
	refinv := make([]string, 0)
	for _, f := range REFERENCES {
		refinv = append(refinv, f)
	}

	newone := strings.Replace(args[1], "_", "-", -1)

	if !stringInSlice(newone, refinv) {
		bot.Answer(msg).Text(fmt.Sprintf("Sorry, %s are not in my references, check the filters with /filters", args[1])).End()
		return nil
	}

	u, ok := subscribers.getUser(msg.From.ID)
	if ok && stringInSlice(newone, u.Zones) {
		bot.Answer(msg).Text(fmt.Sprintf("You are already subscribed to %s!", newone)).End()
		return nil
	}

	newfils := subscribers.addFilter(msg.From.ID, newone)
	saveFilters(msg.From.ID, newfils)
	bot.Answer(msg).Text(fmt.Sprintf("You have been subscribed to %s", newone)).End()
	return nil
}

func rmfilter(bot tgbot.TgBot, msg tgbot.Message, args []string, kargs map[string]string) *string {
	u, ok := subscribers.getUser(msg.From.ID)
	if !ok {
		bot.Answer(msg).Text("You don't have any filter").End()
		return nil
	}

	newone := strings.Replace(args[1], "_", "-", -1)

	if !stringInSlice(newone, u.Zones) {
		bot.Answer(msg).Text(fmt.Sprintf("You don't have the filter %s", args[1])).End()
		return nil
	}

	newfils := subscribers.rmFilter(msg.From.ID, newone)
	saveFilters(msg.From.ID, newfils)
	bot.Answer(msg).Text(fmt.Sprintf("Filter %s removed!", newone)).End()
	return nil
}

func cleanfilters(bot tgbot.TgBot, msg tgbot.Message, text string) *string {
	subscribers.cleanFilters(msg.From.ID)
	bot.Answer(msg).Text("All your filters has been cleaned!").End()
	return nil
}

func myfilters(bot tgbot.TgBot, msg tgbot.Message, text string) *string {
	u, ok := subscribers.getUser(msg.From.ID)
	if !ok {
		bot.Answer(msg).Text("You don't have any filter").End()
		return nil
	}
	filters := "There are your filters:\n"
	sort.Strings(u.Zones)
	for _, v := range u.Zones {
		filters += fmt.Sprintf("%s ( /rmfilter%s )\n", v, strings.Replace(v, "-", "_", -1))
	}
	bot.Answer(msg).Text(filters).End()
	return nil
}

func filters(bot tgbot.TgBot, msg tgbot.Message, text string) *string {
	se := set.New()
	for _, f := range REFERENCES {
		se.Add(f)
	}

	refs := set.StringSlice(se)
	sort.Strings(refs)

	refinv := fmt.Sprintf("There are %d filters:\n----------\n", len(refs))
	for _, f := range refs {
		refinv += fmt.Sprintf("%s ( /addfilter%s )\n", f, strings.Replace(f, "-", "_", -1))
	}
	bot.Answer(msg).Text(refinv).End()
	return nil
}

func loadAllDb() {
	res := make(map[int]User)
	keys := autodb.loadFromDbPrefix("kimsufi:")

	for k, v := range keys {
		kp := strings.Split(k, ":")
		if len(kp) != 3 {
			continue
		}
		id, err := strconv.Atoi(kp[1])
		if err != nil {
			continue
		}
		actual, _ := res[id]
		if kp[2] == "active" {
			res[id] = User{v == "true", actual.Zones}
		} else {
			res[id] = User{actual.Active, strings.Split(v, ":")}
		}
	}

	subscribers.setAll(res)
}

func BuildBot(token string, db *leveldb.DB) *tgbot.TgBot {
	autodb = dbSync{
		&sync.Mutex{},
		db,
	}

	loadAllDb()

	// start - Subscribe to Kimsufi availability news!
	// subscribe - Subscribe to Kimsufi availability news!
	// stop - Unsubscribe to Kimsufi availability news!
	// unsubscribe - Unsubscribe to Kimsufi availability news!
	// addfilter - Add a filter to your subscription.
	// rmfilter - Remove a filter subscribed
	// filters - Show all available filters!
	// myfilters - Show your subscribed filters
	// cleanfilters - Remove all your filters

	bot := tgbot.New(token).
		SimpleCommandFn(`start`, subscribe).
		SimpleCommandFn(`subscribe`, subscribe).
		SimpleCommandFn(`stop`, unsubscribe).
		SimpleCommandFn(`unsubscribe`, unsubscribe).
		MultiCommandFn([]string{`addfilter (.+)`, `addfilter(.+)`}, addfilter).
		MultiCommandFn([]string{`rmfilter (.+)`, `rmfilter(.+)`}, rmfilter).
		SimpleCommandFn(`filters`, filters).
		SimpleCommandFn(`myfilters`, myfilters).
		SimpleCommandFn(`cleanfilters`, cleanfilters)

	go analyzer(*bot)
	return bot
}
